\hypertarget{group__operators}{}\doxysection{Operators}
\label{group__operators}\index{Operators@{Operators}}


Operators is way to modify observables and extend with some extra custom logic.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$details\+::op\+\_\+fn$<$ Specific\+Observable $>$ Operator\+Fn$>$ }\\auto \mbox{\hyperlink{group__operators_ga381218c46daf100859858d88743d058d}{rpp\+::interface\+\_\+observable$<$ Type, Specific\+Observable $>$\+::op}} (Operator\+Fn \&\&fn) const \&
\begin{DoxyCompactList}\small\item\em The apply function to observable which returns observable of another type. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::predicate$<$ const Type \& $>$ Predicate$>$ \newline
requires is\+\_\+header\+\_\+included$<$filter\+\_\+tag, Predicate$>$}\\auto \mbox{\hyperlink{group__operators_gae2695326a24fb8534f17f0d228d3b7f2}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, filter\+\_\+tag $>$\+::filter}} (Predicate \&\&predicate) const \&
\begin{DoxyCompactList}\small\item\em emit only those items from an Observable that satisfies a predicate \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::invocable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$map\+\_\+tag, Callable$>$}\\auto \mbox{\hyperlink{group__operators_gae5dd31e4559517de5cf1145ff2005a86}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map}} (Callable \&\&callable) const \&
\begin{DoxyCompactList}\small\item\em transform the items emitted by an Observable by applying a function to each item \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Args$>$ \newline
requires (is\+\_\+header\+\_\+included$<$merge\+\_\+tag, Args...$>$ \&\& rpp\+::constraint\+::observable$<$Type$>$)}\\auto \mbox{\hyperlink{group__operators_ga84ed0dcdeda6a4cb3a9871ab2817e114}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, merge\+\_\+tag $>$\+::merge}} () const \&
\begin{DoxyCompactList}\small\item\em combine submissions from observables inside this observable into one \end{DoxyCompactList}\item 
{\footnotesize template$<$constraint\+::observable\+\_\+of\+\_\+type$<$ Type $>$ ... TObservables$>$ \newline
requires (is\+\_\+header\+\_\+included$<$merge\+\_\+tag, TObservables...$>$\&\& sizeof...(TObservables) $>$= 1)}\\auto \mbox{\hyperlink{group__operators_gafa55b14eec1c6c40b8655e20c6edf5b2}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, merge\+\_\+tag $>$\+::merge\+\_\+with}} (TObservables \&\&... observables) const \&
\begin{DoxyCompactList}\small\item\em combine submissions from current observable with other observables into one \end{DoxyCompactList}\item 
{\footnotesize template$<$rpp\+::subjects\+::constraint\+::subject\+\_\+of\+\_\+type$<$ Type $>$ TSubject$>$ \newline
requires is\+\_\+header\+\_\+included$<$multicast\+\_\+tag, TSubject$>$}\\auto \mbox{\hyperlink{group__operators_gade414a17091e966ce725374b631cab77}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, multicast\+\_\+tag $>$\+::multicast}} (TSubject \&\&subject) const \&
\begin{DoxyCompactList}\small\item\em converts ordinary observable to Connectable Observable with help of provided subject \end{DoxyCompactList}\item 
{\footnotesize template$<$schedulers\+::constraint\+::scheduler TScheduler$>$ \newline
requires is\+\_\+header\+\_\+included$<$observe\+\_\+on\+\_\+tag, TScheduler$>$}\\auto \mbox{\hyperlink{group__operators_ga374d453301a31f00fed7024be4327934}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, observe\+\_\+on\+\_\+tag $>$\+::observe\+\_\+on}} (TScheduler \&\&scheduler) const \&
\begin{DoxyCompactList}\small\item\em transfer emissions of items to provided scheduler \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$publish\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__operators_ga87aa80f556399c86bafcab5f7b4a7473}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, publish\+\_\+tag $>$\+::publish}} () const \&
\begin{DoxyCompactList}\small\item\em converts ordinary observable to Connectable Observable with help of \mbox{\hyperlink{classrpp_1_1subjects_1_1publish__subject}{rpp\+::subjects\+::publish\+\_\+subject}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$ref\+\_\+count\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__operators_gac1991f003be32f5432ecb084be506c15}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, ref\+\_\+count\+\_\+tag $>$\+::ref\+\_\+count}} () const \&
\begin{DoxyCompactList}\small\item\em Forces connectable observable to behave like common observable. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$repeat\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__operators_ga2a165810b188f9cf9b77255ed725e31a}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, repeat\+\_\+tag $>$\+::repeat}} (size\+\_\+t count) const \&
\begin{DoxyCompactList}\small\item\em Forces observable to re-\/subscribe observer to this observable after on\+\_\+completed provided amount of times. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$repeat\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__operators_ga152a343d0ea926ee04cf64ebb78c5d5e}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, repeat\+\_\+tag $>$\+::repeat}} () const \&
\begin{DoxyCompactList}\small\item\em Forces observable to re-\/subscribe observer to this observable after on\+\_\+completed infinitely. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$take\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__operators_ga0dcb41decfa8d5ded95f828a7e65ffee}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, take\+\_\+tag $>$\+::take}} (size\+\_\+t count) const \&
\begin{DoxyCompactList}\small\item\em emit only first Count items provided by observable \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::predicate$<$ const Type \& $>$ Predicate$>$ \newline
requires is\+\_\+header\+\_\+included$<$take\+\_\+while\+\_\+tag, Predicate$>$}\\auto \mbox{\hyperlink{group__operators_ga47773bfb0298bba2ec71502c1984cc95}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, take\+\_\+while\+\_\+tag $>$\+::take\+\_\+while}} (Predicate \&\&predicate) const \&
\begin{DoxyCompactList}\small\item\em sends items provided by observable while satisfies predicate. When condition becomes false -\/\texorpdfstring{$>$}{>} terminates \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Operators is way to modify observables and extend with some extra custom logic. 

\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators.html}{\texttt{ https\+://reactivex.\+io/documentation/operators.\+html}} 
\end{DoxySeeAlso}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__operators_gae2695326a24fb8534f17f0d228d3b7f2}\label{group__operators_gae2695326a24fb8534f17f0d228d3b7f2}} 
\index{Operators@{Operators}!filter@{filter}}
\index{filter@{filter}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{filter()}{filter()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::predicate$<$ const Type \& $>$ Predicate$>$ \newline
requires is\+\_\+header\+\_\+included$<$filter\+\_\+tag, Predicate$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, filter\+\_\+tag $>$\+::filter (\begin{DoxyParamCaption}\item[{Predicate \&\&}]{predicate }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



emit only those items from an Observable that satisfies a predicate 

The Filter operator applies a provided predicate to each item emitted by the Observable, and returns an Observable that emits only items passed provided predicate

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    rpp::source::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& sub)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; ++i)}
\DoxyCodeLine{                    sub.on\_next(i);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__operators_gae2695326a24fb8534f17f0d228d3b7f2}{filter}}([](\textcolor{keywordtype}{int}    v) \{ \textcolor{keywordflow}{return} v \% 2 == 0; \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 0 2 4 6 8}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/filter.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/filter.\+html}}
\end{DoxySeeAlso}

\begin{DoxyTemplParams}{Template Parameters}
{\em Predicate} & type of predicate used to check emitted itemss \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the Filter operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{filter_8hpp_source}{rpp/operators/filter.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_gae5dd31e4559517de5cf1145ff2005a86}\label{group__operators_gae5dd31e4559517de5cf1145ff2005a86}} 
\index{Operators@{Operators}!map@{map}}
\index{map@{map}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::invocable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$map\+\_\+tag, Callable$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



transform the items emitted by an Observable by applying a function to each item 

The Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications.

The Map operator can keep same type of value or change it to some another type.

Example with same type\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    rpp::source::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& sub)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                sub.on\_next(42);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__operators_gae5dd31e4559517de5cf1145ff2005a86}{map}}([](\textcolor{keywordtype}{int} value)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{return} value + 10;}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 52}}

\end{DoxyCodeInclude}


Example with changed type\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    rpp::source::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& sub)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                sub.on\_next(42);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__operators_gae5dd31e4559517de5cf1145ff2005a86}{map}}([](\textcolor{keywordtype}{int} value)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{return} std::to\_string(value) + \textcolor{stringliteral}{"{} VAL"{}};}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](std::string v) \{ std::cout << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 42 VAL}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/map.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/map.\+html}}
\end{DoxySeeAlso}

\begin{DoxyTemplParams}{Template Parameters}
{\em Callable} & type of callable used to provide this transformation \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the Map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{map_8hpp_source}{rpp/operators/map.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga84ed0dcdeda6a4cb3a9871ab2817e114}\label{group__operators_ga84ed0dcdeda6a4cb3a9871ab2817e114}} 
\index{Operators@{Operators}!merge@{merge}}
\index{merge@{merge}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{merge()}{merge()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename ... Args$>$ \newline
requires (is\+\_\+header\+\_\+included$<$merge\+\_\+tag, Args...$>$ \&\& rpp\+::constraint\+::observable$<$Type$>$)\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, merge\+\_\+tag $>$\+::merge (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



combine submissions from observables inside this observable into one 

this overloading of Merge operator can be applied for observable of observables and will merge emissions of observables inside root observable \textbackslash{}warn According to observable contract (\href{https://reactivex.io/documentation/contract.html}{\texttt{ https\+://reactivex.\+io/documentation/contract.\+html}}) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(\mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1).as\_dynamic(),}
\DoxyCodeLine{                      rpp::source::never<int>().as\_dynamic(),}
\DoxyCodeLine{                      \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(2).as\_dynamic())}
\DoxyCodeLine{            .merge()}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 2}}

\end{DoxyCodeInclude}
 \begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/merge.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/merge.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the merge operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{merge_8hpp_source}{rpp/operators/merge.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_gafa55b14eec1c6c40b8655e20c6edf5b2}\label{group__operators_gafa55b14eec1c6c40b8655e20c6edf5b2}} 
\index{Operators@{Operators}!merge\_with@{merge\_with}}
\index{merge\_with@{merge\_with}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{merge\_with()}{merge\_with()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$constraint\+::observable\+\_\+of\+\_\+type$<$ Type $>$ ... TObservables$>$ \newline
requires (is\+\_\+header\+\_\+included$<$merge\+\_\+tag, TObservables...$>$\&\& sizeof...(TObservables) $>$= 1)\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, merge\+\_\+tag $>$\+::merge\+\_\+with (\begin{DoxyParamCaption}\item[{TObservables \&\&...}]{observables }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



combine submissions from current observable with other observables into one 

this overloading of Merge operator can be applied to any observable to merge emissions with other observables from arguments \textbackslash{}warn According to observable contract (\href{https://reactivex.io/documentation/contract.html}{\texttt{ https\+://reactivex.\+io/documentation/contract.\+html}}) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1)}
\DoxyCodeLine{            .merge\_with(\mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(2))}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 2}}

\end{DoxyCodeInclude}
 \begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/merge.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/merge.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the merge operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{merge_8hpp_source}{rpp/operators/merge.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_gade414a17091e966ce725374b631cab77}\label{group__operators_gade414a17091e966ce725374b631cab77}} 
\index{Operators@{Operators}!multicast@{multicast}}
\index{multicast@{multicast}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{multicast()}{multicast()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$rpp\+::subjects\+::constraint\+::subject\+\_\+of\+\_\+type$<$ Type $>$ TSubject$>$ \newline
requires is\+\_\+header\+\_\+included$<$multicast\+\_\+tag, TSubject$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, multicast\+\_\+tag $>$\+::multicast (\begin{DoxyParamCaption}\item[{TSubject \&\&}]{subject }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



converts ordinary observable to Connectable Observable with help of provided subject 

Connectable observable is common observable, but actually it starts emissions of items only after call \char`\"{}connect\char`\"{}, \char`\"{}ref\+\_\+count\char`\"{} or any other available way. Also it uses subject to multicast values to subscribers


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{keyword}{auto} subject = \mbox{\hyperlink{classrpp_1_1subjects_1_1publish__subject}{rpp::subjects::publish\_subject<int>}}\{\};}
\DoxyCodeLine{    \textcolor{keyword}{auto} observable = \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1, 2, 3).multicast(subject);}
\DoxyCodeLine{    observable.subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#1 "{}} << v << std::endl; \});}
\DoxyCodeLine{    observable.subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#2 "{}} << v << std::endl; \});}
\DoxyCodeLine{    observable.connect();}
\DoxyCodeLine{    \textcolor{comment}{// Output:}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 3}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 3}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/publish.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/publish.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the multicast operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}rpp/operators/multicast.\+h\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga374d453301a31f00fed7024be4327934}\label{group__operators_ga374d453301a31f00fed7024be4327934}} 
\index{Operators@{Operators}!observe\_on@{observe\_on}}
\index{observe\_on@{observe\_on}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{observe\_on()}{observe\_on()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$schedulers\+::constraint\+::scheduler TScheduler$>$ \newline
requires is\+\_\+header\+\_\+included$<$observe\+\_\+on\+\_\+tag, TScheduler$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, observe\+\_\+on\+\_\+tag $>$\+::observe\+\_\+on (\begin{DoxyParamCaption}\item[{TScheduler \&\&}]{scheduler }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



transfer emissions of items to provided scheduler 

after applying this operator all next emissions will be provided via scheduler

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    std::cout << std::this\_thread::get\_id() << std::endl;}
\DoxyCodeLine{    \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(10, 15, 20)}
\DoxyCodeLine{            .observe\_on(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\})}
\DoxyCodeLine{            .as\_blocking()}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << \textcolor{stringliteral}{"{}["{}} << std::this\_thread::get\_id() << \textcolor{stringliteral}{"{}] : "{}} << v << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Template for output:}}
\DoxyCodeLine{    \textcolor{comment}{// TH1}}
\DoxyCodeLine{    \textcolor{comment}{// [TH2]: 10}}
\DoxyCodeLine{    \textcolor{comment}{// [TH2]: 15}}
\DoxyCodeLine{    \textcolor{comment}{// [TH2]: 20}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/observeon.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/observeon.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the observe\+\_\+on operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{observe__on_8hpp_source}{rpp/operators/observe\+\_\+on.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga381218c46daf100859858d88743d058d}\label{group__operators_ga381218c46daf100859858d88743d058d}} 
\index{Operators@{Operators}!op@{op}}
\index{op@{op}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{op()}{op()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$details\+::op\+\_\+fn$<$ Specific\+Observable $>$ Operator\+Fn$>$ \\
auto \mbox{\hyperlink{structrpp_1_1interface__observable}{rpp\+::interface\+\_\+observable}}$<$ Type, Specific\+Observable $>$\+::op (\begin{DoxyParamCaption}\item[{Operator\+Fn \&\&}]{fn }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



The apply function to observable which returns observable of another type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Operator\+Fn} & type of function which applies to this observable \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} of New\+Type 
\end{DoxyReturn}
\mbox{\Hypertarget{group__operators_ga87aa80f556399c86bafcab5f7b4a7473}\label{group__operators_ga87aa80f556399c86bafcab5f7b4a7473}} 
\index{Operators@{Operators}!publish@{publish}}
\index{publish@{publish}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{publish()}{publish()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$publish\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, publish\+\_\+tag $>$\+::publish (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



converts ordinary observable to Connectable Observable with help of \mbox{\hyperlink{classrpp_1_1subjects_1_1publish__subject}{rpp\+::subjects\+::publish\+\_\+subject}} 

Connectable observable is common observable, but actually it starts emissions of items only after call \char`\"{}connect\char`\"{}, \char`\"{}ref\+\_\+count\char`\"{} or any other available way. Also it uses subject to multicast values to subscribers


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{keyword}{auto} observable = \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1,2,3).publish();}
\DoxyCodeLine{    observable.subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#1 "{}} << v << std::endl; \});}
\DoxyCodeLine{    observable.subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#2 "{}} << v << std::endl; \});}
\DoxyCodeLine{    observable.connect();}
\DoxyCodeLine{    \textcolor{comment}{// Output:}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 3}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 3}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/publish.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/publish.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the publish operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}rpp/operators/publish.\+h\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_gac1991f003be32f5432ecb084be506c15}\label{group__operators_gac1991f003be32f5432ecb084be506c15}} 
\index{Operators@{Operators}!ref\_count@{ref\_count}}
\index{ref\_count@{ref\_count}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{ref\_count()}{ref\_count()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$ref\+\_\+count\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, ref\+\_\+count\+\_\+tag $>$\+::ref\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Forces connectable observable to behave like common observable. 

Connects Connectable Observable on the first subscription and unsubscribes on last unsubscription


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{keyword}{auto} observable = \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1, 2, 3).publish();}
\DoxyCodeLine{    observable.subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#1 "{}} << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// No Output}}
\DoxyCodeLine{}
\DoxyCodeLine{    observable.ref\_count().subscribe([](\textcolor{keywordtype}{int} v) \{std::cout << \textcolor{stringliteral}{"{}\#2 "{}} << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output:}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 1}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 2}}
\DoxyCodeLine{    \textcolor{comment}{// \#1 3}}
\DoxyCodeLine{    \textcolor{comment}{// \#2 3}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/refcount.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/refcount.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the ref\+\_\+count operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}rpp/operators/ref\+\_\+count.\+h\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga152a343d0ea926ee04cf64ebb78c5d5e}\label{group__operators_ga152a343d0ea926ee04cf64ebb78c5d5e}} 
\index{Operators@{Operators}!repeat@{repeat}}
\index{repeat@{repeat}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$repeat\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, repeat\+\_\+tag $>$\+::repeat (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Forces observable to re-\/subscribe observer to this observable after on\+\_\+completed infinitely. 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1, 2, 3)}
\DoxyCodeLine{            .repeat()}
\DoxyCodeLine{            .take(10)}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \},}
\DoxyCodeLine{                       []()}
\DoxyCodeLine{                       \{}
\DoxyCodeLine{                           std::cout << \textcolor{stringliteral}{"{}completed"{}} << std::endl;}
\DoxyCodeLine{                       \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 2 3 1 2 3 1 2 3 1 completed}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/repeat.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/repeat.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the repeat operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}rpp/operators/repeat.\+h\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga2a165810b188f9cf9b77255ed725e31a}\label{group__operators_ga2a165810b188f9cf9b77255ed725e31a}} 
\index{Operators@{Operators}!repeat@{repeat}}
\index{repeat@{repeat}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$repeat\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, repeat\+\_\+tag $>$\+::repeat (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Forces observable to re-\/subscribe observer to this observable after on\+\_\+completed provided amount of times. 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__observables_ga819797b9fb7452311dedc62aa94d1f7b}{rpp::source::just}}(1, 2, 3)}
\DoxyCodeLine{            .repeat(2)}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \},}
\DoxyCodeLine{                       []()}
\DoxyCodeLine{                       \{}
\DoxyCodeLine{                           std::cout << \textcolor{stringliteral}{"{}completed"{}} << std::endl;}
\DoxyCodeLine{                       \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 2 3 1 2 3 completed}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/repeat.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/repeat.\+html}}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em count} & total amoun of times subscription happens. For example\+:
\begin{DoxyItemize}
\item {\ttfamily count(0)} -\/ means no any subscription at all
\item {\ttfamily count(1)} -\/ behave like ordinal observable
\item {\ttfamily count(10)} -\/ 1 normal subscription and 9 re-\/subscriptions during on\+\_\+completed 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the repeat operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}rpp/operators/repeat.\+h\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga0dcb41decfa8d5ded95f828a7e65ffee}\label{group__operators_ga0dcb41decfa8d5ded95f828a7e65ffee}} 
\index{Operators@{Operators}!take@{take}}
\index{take@{take}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{take()}{take()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$take\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, take\+\_\+tag $>$\+::take (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



emit only first Count items provided by observable 

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    rpp::source::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& sub)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; ++i)}
\DoxyCodeLine{                    sub.on\_next(i);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__operators_ga0dcb41decfa8d5ded95f828a7e65ffee}{take}}(2)}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 0 1}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/take.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/take.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the Take operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{take_8hpp_source}{rpp/operators/take.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
\mbox{\Hypertarget{group__operators_ga47773bfb0298bba2ec71502c1984cc95}\label{group__operators_ga47773bfb0298bba2ec71502c1984cc95}} 
\index{Operators@{Operators}!take\_while@{take\_while}}
\index{take\_while@{take\_while}!Operators@{Operators}}
\doxysubsubsection{\texorpdfstring{take\_while()}{take\_while()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::predicate$<$ const Type \& $>$ Predicate$>$ \newline
requires is\+\_\+header\+\_\+included$<$take\+\_\+while\+\_\+tag, Predicate$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, take\+\_\+while\+\_\+tag $>$\+::take\+\_\+while (\begin{DoxyParamCaption}\item[{Predicate \&\&}]{predicate }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



sends items provided by observable while satisfies predicate. When condition becomes false -\/\texorpdfstring{$>$}{>} terminates 

Example\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    rpp::source::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& sub)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; ++i)}
\DoxyCodeLine{                    sub.on\_next(i);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__operators_ga47773bfb0298bba2ec71502c1984cc95}{take\_while}}([](\textcolor{keywordtype}{int} v) \{ \textcolor{keywordflow}{return} v != 5; \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int}  v) \{ std::cout << v << \textcolor{stringliteral}{"{} "{}}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 0 1 2 3 4}}

\end{DoxyCodeInclude}


\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/takewhile.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/takewhile.\+html}}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the take\+\_\+while operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\mbox{\hyperlink{take__while_8hpp_source}{rpp/operators/take\+\_\+while.\+hpp}}\texorpdfstring{$>$}{>} 
\end{DoxyWarning}
